<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>FRC RAG</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}?v=6">
    <link rel="stylesheet" href="{{ url_for('static', filename='custom.css') }}?v=6">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Syntax highlighting for code blocks -->
    <link href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css" rel="stylesheet">
    <!-- Markdown renderer and sanitizer -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/common.min.js"></script>
</head>

<body class="font-sans bg-background text-foreground h-screen overflow-hidden">
    <div class="flex h-screen bg-background relative">
        <!-- Sidebar -->
        <div
            class="w-[260px] bg-[#171717] border-r border-[#2f2f2f] flex flex-col transition-transform duration-300 flex-shrink-0 relative z-[100] sidebar collapsed">
            <div class="p-3.5 border-b border-[#2f2f2f]">
                <div class="flex items-center gap-3 mb-4 text-foreground">
                    <div
                        class="w-8 h-8 bg-gradient-to-br from-primary to-primary/80 rounded-lg flex items-center justify-center text-white text-base">
                        <i class="fas fa-robot"></i>
                    </div>
                    <div class="font-semibold text-lg">FRC RAG</div>
                </div>
                <button
                    class="w-full px-4 py-3 bg-secondary border border-[#424242] rounded-md text-foreground cursor-pointer flex items-center gap-3 text-sm transition-colors hover:bg-[#3f3f3f]">
                    <i class="fas fa-plus"></i>
                    New Chat
                </button>
            </div>
            <div class="flex-1 overflow-y-auto p-2">
                <div class="chat-history">
                    <!-- Chat history will go here -->
                </div>
            </div>
            <div class="p-3.5 border-t border-[#2f2f2f]">
                <div class="flex items-center gap-3 text-foreground text-sm">
                    <div class="w-7 h-7 bg-[#424242] rounded-full flex items-center justify-center text-xs">
                        <i class="fas fa-user"></i>
                    </div>
                    <span>User</span>
                </div>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div
            class="main-chat flex-1 flex flex-col bg-background min-w-0 transition-[margin-left] duration-300 relative">
            <!-- Header -->
            <div class="bg-background border-b border-[#2f2f2f] px-5 py-4 flex items-center min-h-[60px] relative">
                <div class="flex items-center gap-4 w-full">
                    <button
                        class="bg-none border-none text-foreground text-base cursor-pointer p-2 rounded-md transition-colors hover:bg-secondary flex-shrink-0"
                        id="sidebarToggle">
                        <i class="fas fa-bars"></i>
                    </button>
                    <div class="ml-0">
                        <h1 class="text-xl font-semibold text-foreground m-0">FRC RAG</h1>
                    </div>
                </div>
            </div>

            <!-- Chat Messages Area -->
            <div class="flex-1 overflow-y-auto bg-background scroll-smooth relative" id="chatMessages">
                <div class="message assistant-message welcome-message">
                    <div class="message-content">
                        <div class="message-avatar">
                            <div class="assistant-avatar">
                                <i class="fas fa-robot"></i>
                            </div>
                        </div>
                        <div class="message-text-container">
                            <div class="message-text">
                                <h3 class="font-bold">Welcome to FRC RAG! ðŸ¤–</h3>
                                <p>I can help you with First Robotics Competition questions using data from team
                                    technical binders. Here's what I can do:</p>
                                <ul>
                                    <li><strong>Answer technical questions</strong> about FRC robots, mechanisms, and
                                        strategies</li>
                                    <li><strong>Find relevant images</strong> from team documentation</li>
                                    <li><strong>Explain game pieces and mechanisms</strong> with enhanced context</li>
                                    <li><strong>Provide detailed analysis</strong> based on team technical documentation
                                    </li>
                                </ul>
                                <p>Try asking me something like:</p>
                                <ul>
                                    <li>"How do teams handle ground intake?"</li>
                                    <li>"Show me swerve drive implementations"</li>
                                    <li>"What are common scoring mechanisms?"</li>
                                </ul>
                                <p><strong>Just type your question below to get started!</strong></p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Input Area -->
            <div class="bg-background p-5 border-t border-[#2f2f2f]">
                <div class="max-w-3xl mx-auto">
                    <div
                        class="relative flex items-center bg-secondary border-2 border-[#424242] rounded-3xl px-4 py-3 transition-colors focus-within:border-primary">
                        <textarea id="messageInput" placeholder="Ask me anything about FRC..."
                            class="flex-1 bg-transparent border-none outline-none text-foreground text-base leading-normal p-0 resize-none max-h-[200px] overflow-y-auto placeholder:text-[#8e8ea0]"></textarea>
                        <button id="sendButton"
                            class="w-8 h-8 border-none rounded-2xl bg-primary text-white cursor-pointer flex items-center justify-center transition-colors text-sm ml-2 flex-shrink-0 hover:bg-primary/90 disabled:bg-[#424242] disabled:cursor-not-allowed">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Scroll to bottom button -->
            <button
                class="absolute bottom-[100px] left-1/2 -translate-x-1/2 w-10 h-10 rounded-full bg-secondary border border-[#424242] text-foreground cursor-pointer flex items-center justify-center text-base transition-all z-[1000] shadow-lg hover:bg-[#3f3f3f] hover:scale-110 active:scale-95"
                id="scrollToBottomBtn" style="display: none;">
                <i class="fas fa-arrow-down"></i>
            </button>
        </div>

        <!-- Loading Indicator -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-box">
                <div class="loading-content">
                    <div class="loading-stage" id="loadingStage">Querying</div>
                    <div class="loading-progress">
                        <div class="loading-bar" id="loadingBar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Modal -->
    <div class="image-modal" id="imageModal">
        <div class="image-modal-content">
            <span class="image-modal-close" id="modalClose">&times;</span>
            <img class="image-modal-img" id="modalImage" src="" alt="">
            <div class="image-modal-info" id="modalInfo">
                <h3 id="modalTitle"></h3>
                <p id="modalDescription"></p>
            </div>
        </div>
    </div>

    <script>
        function addMessage(text, sender, images = [], isError = false, enhancedData = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message${isError ? ' error-message' : ''}`;

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            if (sender === 'user') {
                avatarDiv.innerHTML = '<div class="user-avatar"><i class="fas fa-user"></i></div>';
            } else {
                avatarDiv.innerHTML = '<div class="assistant-avatar"><i class="fas fa-robot"></i></div>';
            }

            const textContentDiv = document.createElement('div');
            textContentDiv.className = 'message-text-container';

            // Add game piece mapping info if available
            if (enhancedData && enhancedData.matched_pieces) {
                let matchedPiecesText = '';
                if (Array.isArray(enhancedData.matched_pieces)) {
                    matchedPiecesText = enhancedData.matched_pieces.join(', ');
                } else {
                    matchedPiecesText = enhancedData.matched_pieces.toString();
                }

                if (matchedPiecesText.trim()) {
                    const mappingDiv = document.createElement('div');
                    mappingDiv.className = 'game-piece-mapping';
                    mappingDiv.innerHTML = `
                        <div class="mapping-header">
                            <i class="fas fa-link"></i> Game Piece Mapping
                        </div>
                        <div class="mapping-content">
                            Detected: <strong>${matchedPiecesText}</strong>
                            ${enhancedData.enhanced_query !== enhancedData.query ?
                            `<br><small>Enhanced search: "${enhancedData.enhanced_query}"</small>` : ''}
                        </div>
                    `;
                    textContentDiv.appendChild(mappingDiv);
                }
            }

            const textDiv = document.createElement('div');
            textDiv.className = 'message-text';
            textDiv.innerHTML = formatText(text);

            textContentDiv.appendChild(textDiv);
            try {
                textDiv.querySelectorAll('pre code').forEach((block) => {
                    if (window.hljs) window.hljs.highlightElement(block);
                });
            } catch (e) { /* no-op */ }

            // Add images if present
            if (images && images.length > 0) {
                const imagesDiv = document.createElement('div');
                imagesDiv.className = 'message-images';

                const imageHeader = document.createElement('div');
                imageHeader.className = 'image-header';
                imageHeader.innerHTML = `<i class="fas fa-images"></i> Related Images (${images.length})`;
                imagesDiv.appendChild(imageHeader);

                const imageGrid = document.createElement('div');
                imageGrid.className = 'image-grid';

                images.forEach((image, index) => {
                    const imageItem = createImageItem(image, index);
                    imageGrid.appendChild(imageItem);
                });

                imagesDiv.appendChild(imageGrid);
                textContentDiv.appendChild(imagesDiv);
            }

            // Add feedback buttons for assistant messages (non-error)
            if (sender === 'assistant' && !isError) {
                const feedbackDiv = document.createElement('div');
                feedbackDiv.className = 'feedback-buttons';

                const feedbackLabel = document.createElement('div');
                feedbackLabel.className = 'feedback-label';
                feedbackLabel.textContent = 'Was this response helpful?';

                const buttonsContainer = document.createElement('div');
                buttonsContainer.className = 'feedback-button-container';
                const goodButton = document.createElement('button');
                goodButton.className = 'feedback-btn feedback-good';
                goodButton.innerHTML = '<i class="fas fa-thumbs-up"></i> Good';
                goodButton.onclick = () => submitFeedback(text, 'good', feedbackDiv);
                const badButton = document.createElement('button');
                badButton.className = 'feedback-btn feedback-bad';
                badButton.innerHTML = '<i class="fas fa-thumbs-down"></i> Bad';
                badButton.onclick = () => submitFeedback(text, 'bad', feedbackDiv);

                buttonsContainer.appendChild(goodButton);
                buttonsContainer.appendChild(badButton);
                messageDiv.classList.add('latest-assistant-message');

                feedbackDiv.appendChild(feedbackLabel);
                feedbackDiv.appendChild(buttonsContainer);

                textContentDiv.appendChild(feedbackDiv);
            }

            contentDiv.appendChild(avatarDiv);
            contentDiv.appendChild(textContentDiv);

            messageDiv.appendChild(contentDiv);

            const chatMessages = document.getElementById('chatMessages');
            chatMessages.appendChild(messageDiv);

            // If this is an assistant message, manage redo button visibility
            if (sender === 'assistant' && !isError) {
                // Remove redo button from all previous assistant messages
                const previousLatestMessages = chatMessages.querySelectorAll('.latest-assistant-message');
                previousLatestMessages.forEach(msg => {
                    if (msg !== messageDiv) {
                        msg.classList.remove('latest-assistant-message');
                        const redoBtn = msg.querySelector('.feedback-redo');
                        if (redoBtn) {
                            redoBtn.remove();
                        }
                    }
                });

                // Add redo button to the current (latest) message
                const buttonsContainer = messageDiv.querySelector('.feedback-button-container');
                if (buttonsContainer) {
                    const redoButton = document.createElement('button');
                    redoButton.className = 'feedback-btn feedback-redo';
                    redoButton.innerHTML = '<i class="fas fa-redo"></i> Redo';
                    redoButton.onclick = () => submitFeedback(text, 'redo', messageDiv.querySelector('.feedback-buttons'));
                    buttonsContainer.appendChild(redoButton);
                }
            }

            autoScrollToBottom();
        }

        function createImageItem(image, index) {
            const imageDiv = document.createElement('div');
            imageDiv.className = 'image-item';

            if (image.exists) {
                const imgContainer = document.createElement('div');
                imgContainer.className = 'image-thumbnail-container';

                const img = document.createElement('img');
                img.src = `/images/${image.web_path}`;
                img.alt = image.filename;
                img.className = 'image-thumbnail';

                const overlay = document.createElement('div');
                overlay.className = 'image-overlay';
                overlay.innerHTML = `
                    <i class="fas fa-search-plus"></i>
                    <span>Click to view</span>
                `;
                const clickHandler = () => openImageModal(image);
                imgContainer.addEventListener('click', clickHandler);

                imgContainer.appendChild(img);
                imgContainer.appendChild(overlay);
                imageDiv.appendChild(imgContainer);
            } else {
                imageDiv.className += ' image-not-found';
                imageDiv.innerHTML = `
                    <div class="image-placeholder">
                        <i class="fas fa-image"></i>
                        <span>Image not found</span>
                    </div>
                `;
            }

            const infoDiv = document.createElement('div');
            infoDiv.className = 'image-info';
            const basicInfo = document.createElement('div');
            basicInfo.className = 'image-basic-info';
            basicInfo.innerHTML = `
                <div class="image-filename">${getTeamDisplayName(image.web_path || image.file_path)}</div>
                <div class="image-page">Page ${image.page || 'N/A'}</div>
            `;
            infoDiv.appendChild(basicInfo);

            // Add context summary if available with improved formatting
            if (image.context_summary && image.context_summary.trim()) {
                const contextDiv = document.createElement('div');
                contextDiv.className = 'image-context-summary';
                let contextText = image.context_summary.trim();
                if (contextText.length > 120) {
                    contextText = contextText.substring(0, 120) + '...';
                }

                contextDiv.innerHTML = `
                    <div class="context-label"><i class="fas fa-info-circle"></i> Context</div>
                    <div class="context-text">${contextText}</div>
                `;
                infoDiv.appendChild(contextDiv);
            }
            infoDiv.addEventListener('click', (e) => {
                e.stopPropagation();
                if (image.exists) {
                    openImageModal(image);
                }
            });

            imageDiv.appendChild(infoDiv);
            return imageDiv;
        }

        function openImageModal(image) {
            const imageModal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            const modalTitle = document.getElementById('modalTitle');
            const modalDescription = document.getElementById('modalDescription');

            console.log('Opening modal for image:', image.filename);
            modalImage.src = `/images/${image.web_path}`;
            modalTitle.textContent = getTeamDisplayName(image.web_path || image.file_path);

            let modalContent = `
                <strong>Page:</strong> ${image.page || 'N/A'}<br>
                <strong>Path:</strong> ${image.file_path}<br>
            `;

            // Show formatted context if available, otherwise fall back to OCR text
            if (image.formatted_context && image.formatted_context.trim()) {
                modalContent += `<div class="formatted-context"><strong>Context:</strong><br><pre class="context-content">${image.formatted_context}</pre></div>`;
            } else if (image.ocr_text && image.ocr_text.trim()) {
                modalContent += `<div class="formatted-context"><strong>OCR Text:</strong><br><pre class="context-content">${image.ocr_text}</pre></div>`;
            }

            modalDescription.innerHTML = modalContent;
            imageModal.style.display = 'block';
            console.log('Modal should now be visible');
        }

        function closeModal() {
            const imageModal = document.getElementById('imageModal');
            imageModal.style.display = 'none';
        }

        function formatText(text) {
            try {
                marked.setOptions({ gfm: true, breaks: true, headerIds: false, mangle: false });
                const html = marked.parse(text || '');
                const sanitized = DOMPurify.sanitize(html);
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = sanitized;
                const tables = tempDiv.querySelectorAll('table');
                tables.forEach(table => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'table-wrapper';
                    table.parentNode.insertBefore(wrapper, table);
                    wrapper.appendChild(table);
                });

                return tempDiv.innerHTML;
            } catch (err) {
                const escaped = (text || '')
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/\n/g, '<br>');
                return escaped;
            }
        }

        function showLoading() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingStage = document.getElementById('loadingStage');
            loadingOverlay.style.display = 'flex';
            loadingStage.textContent = 'Querying';
            setTimeout(() => {
                loadingStage.textContent = 'Processing';
            }, 800);

            setTimeout(() => {
                loadingStage.textContent = 'Finishing up';
            }, 2000);
        }

        function hideLoading() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.style.display = 'none';
        }

        function scrollToBottom() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function hasMessageReachedTop(messageElement) {
            if (!messageElement || !chatMessages) return false;
            const chatRect = chatMessages.getBoundingClientRect();
            const messageRect = messageElement.getBoundingClientRect();
            return messageRect.top <= chatRect.top;
        }

        function checkPendingTopMessage(force = false) {
            if (!pendingTopMessage) return;

            if (force || hasMessageReachedTop(pendingTopMessage)) {
                console.log('Pending message reached top, disabling auto-scroll.');
                pendingTopMessage = null;
                isAutoScrollEnabled = false;
                if (!isAtBottom()) {
                    scrollToBottomBtn.style.display = 'block';
                }
            }
        }

        function getTeamDisplayName(imagePath) {
            const pathParts = imagePath.split('/');
            for (let part of pathParts) {
                const match = part.match(/^(\d+)-(\d{4})$/);
                if (match) {
                    const teamNumber = match[1];
                    return `FRC ${teamNumber}`;
                }
            }
            return imagePath.split('/').pop();
        }

        // DOM Elements
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const imageModal = document.getElementById('imageModal');
        const modalImage = document.getElementById('modalImage');
        const modalTitle = document.getElementById('modalTitle');
        const modalDescription = document.getElementById('modalDescription');
        const modalClose = document.getElementById('modalClose');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const scrollToBottomBtn = document.getElementById('scrollToBottomBtn');

        // Global variable to store the current query for feedback
        let currentQuery = '';

        // Conversation history for context
        let conversationHistory = [];

        // Scroll management
        let isAutoScrollEnabled = false; // Start disabled by default
        let isUserScrolling = false; // Track if user is manually scrolling
        let lastScrollTop = 0;
        let isProgrammaticScroll = false; // Flag to track our own scrolls
        let pendingTopMessage = null;

        // Check if user is at bottom of chat
        function isAtBottom() {
            const threshold = 50; // pixels from bottom
            return chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight < threshold;
        }
        function autoScrollToBottom() {
            if (isAutoScrollEnabled && !isUserScrolling) {
                isProgrammaticScroll = true;
                chatMessages.scrollTop = chatMessages.scrollHeight;
                lastScrollTop = chatMessages.scrollTop;
                scrollToBottomBtn.style.display = 'none';
                if (window.scrollTimeout) clearTimeout(window.scrollTimeout);
                window.scrollTimeout = setTimeout(() => { isProgrammaticScroll = false; }, 100);
            } else if (!isAutoScrollEnabled && !isAtBottom()) {
                scrollToBottomBtn.style.display = 'block';
            }
        }

        // Force scroll to bottom (when user clicks button)
        function scrollToBottom() {
            console.log('Scroll button clicked - enabling follow mode');
            isAutoScrollEnabled = true;
            isUserScrolling = false;
            isProgrammaticScroll = true;
            chatMessages.scrollTop = chatMessages.scrollHeight;
            lastScrollTop = chatMessages.scrollTop;
            scrollToBottomBtn.style.display = 'none';
            if (window.scrollTimeout) clearTimeout(window.scrollTimeout);
            window.scrollTimeout = setTimeout(() => { isProgrammaticScroll = false; }, 100);
        }
        chatMessages.addEventListener('scroll', function (e) {
            if (isProgrammaticScroll) {
                console.log('Ignoring programmatic scroll');
                return;
            }

            const currentScrollTop = chatMessages.scrollTop;
            if (isAutoScrollEnabled) {
                console.log('User scrolled - disabling follow mode');
            }
            isUserScrolling = true;
            isAutoScrollEnabled = false;
            pendingTopMessage = null;
            if (!isAtBottom()) {
                scrollToBottomBtn.style.display = 'block';
            } else {
                scrollToBottomBtn.style.display = 'none';
            }

            lastScrollTop = currentScrollTop;
        });

        // Scroll to bottom button click
        scrollToBottomBtn.addEventListener('click', scrollToBottom);

        // Feedback function
        function submitFeedback(responseText, feedbackType, feedbackDiv) {
            const buttons = feedbackDiv.querySelectorAll('.feedback-btn');
            buttons.forEach(btn => btn.disabled = true);
            const buttonsContainer = feedbackDiv.querySelector('.feedback-button-container');
            buttonsContainer.innerHTML = '<span class="feedback-loading"><i class="fas fa-spinner fa-spin"></i> Submitting feedback...</span>';

            fetch('/api/feedback', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query: currentQuery,
                    response: responseText,
                    feedback_type: feedbackType
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        buttonsContainer.innerHTML = `<span class="feedback-success"><i class="fas fa-check"></i> Thank you for your feedback!</span>`;
                        if (feedbackType === 'redo') {
                            setTimeout(() => {
                                messageInput.value = currentQuery;
                                sendMessage();
                            }, 1000);
                        }
                    } else {
                        buttonsContainer.innerHTML = '<span class="feedback-error"><i class="fas fa-exclamation-triangle"></i> Failed to submit feedback</span>';
                        setTimeout(() => {
                            location.reload();
                        }, 2000);
                    }
                })
                .catch(error => {
                    console.error('Feedback error:', error);
                    buttonsContainer.innerHTML = '<span class="feedback-error"><i class="fas fa-exclamation-triangle"></i> Failed to submit feedback</span>';
                    setTimeout(() => {
                        location.reload();
                    }, 2000);
                });
        }

        // Sidebar toggle functionality
        sidebarToggle.addEventListener('click', function () {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('collapsed');
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function (e) {
            const sidebar = document.querySelector('.sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            if (window.innerWidth <= 768) {
                if (!sidebar.classList.contains('collapsed') &&
                    !sidebar.contains(e.target) &&
                    !sidebarToggle.contains(e.target)) {
                    sidebar.classList.add('collapsed');
                }
            }
        });

        // Event Listeners
        console.log('Setting up event listeners...');
        console.log('sendButton:', sendButton);
        console.log('messageInput:', messageInput);

        sendButton.addEventListener('click', function () {
            console.log('Send button clicked!');
            sendMessage();
        });

        messageInput.addEventListener('keypress', function (e) {
            console.log('Key pressed:', e.key);
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        modalClose.addEventListener('click', closeModal);
        imageModal.addEventListener('click', function (e) {
            if (e.target === imageModal) {
                closeModal();
            }
        });

        // Functions
        function sendMessage() {
            console.log('sendMessage function called');
            const message = messageInput.value.trim();
            console.log('Message:', message);
            if (!message) {
                console.log('No message, returning');
                return;
            }
            currentQuery = message;

            // Add user message to conversation history
            conversationHistory.push({
                role: 'user',
                content: message
            });
            if (conversationHistory.length > 20) {
                conversationHistory = conversationHistory.slice(-20);
            }

            console.log('Adding user message to chat');
            // Add user message to chat
            addMessage(message, 'user');

            // Clear input
            messageInput.value = '';

            // Show loading
            showLoading();
            const userMessages = chatMessages.querySelectorAll('.user-message');
            const lastUserMessage = userMessages[userMessages.length - 1];
            if (lastUserMessage) {
                pendingTopMessage = lastUserMessage;
                isAutoScrollEnabled = true;
                isUserScrolling = false;
                scrollToBottomBtn.style.display = 'none';
                isProgrammaticScroll = true;
                chatMessages.scrollTop = chatMessages.scrollHeight;
                if (window.scrollTimeout) clearTimeout(window.scrollTimeout);
                window.scrollTimeout = setTimeout(() => { isProgrammaticScroll = false; }, 100);
            }
            sendMessageWithStreaming(message);
        }

        function sendMessageWithStreaming(message) {
            console.log('Sending streaming request to backend...');
            let assistantMessageDiv = null;
            let textDiv = null;
            let currentText = '';
            let metadata = null;
            let hasRenderedVisibleContent = false;
            let pendingUpdate = false;
            let lastUpdateTime = 0;
            let updateTimeout = null;
            const UPDATE_INTERVAL = 200;
            let tableScrollPositions = [];
            let isTableInteracting = false;
            let shouldRunAfterInteraction = false;

            function attachTableInteractionHandlers() {
                if (!textDiv) return;
                textDiv.querySelectorAll('.table-wrapper').forEach(wrapper => {
                    if (wrapper.dataset.interactionBound === 'true') return;
                    wrapper.dataset.interactionBound = 'true';

                    const startInteraction = () => {
                        isTableInteracting = true;
                    };
                    const endInteraction = () => {
                        if (!isTableInteracting) return;
                        isTableInteracting = false;
                        if (shouldRunAfterInteraction) {
                            shouldRunAfterInteraction = false;
                            updateContent(true);
                        }
                    };

                    wrapper.addEventListener('pointerdown', startInteraction, { passive: true });
                    wrapper.addEventListener('pointerup', endInteraction, { passive: true });
                    wrapper.addEventListener('pointerleave', endInteraction, { passive: true });
                    wrapper.addEventListener('pointercancel', endInteraction, { passive: true });
                });
            }

            function updateContent(force = false) {
                if (!textDiv) return;
                if (!force && isTableInteracting) {
                    shouldRunAfterInteraction = true;
                    pendingUpdate = true;
                    return;
                }
                const currentWrappers = Array.from(textDiv.querySelectorAll('.table-wrapper'));
                tableScrollPositions = currentWrappers.map(wrapper => wrapper.scrollLeft);
                textDiv.innerHTML = formatText(currentText) + '<span class="streaming-cursor">|</span>';
                requestAnimationFrame(() => {
                    const refreshedWrappers = textDiv.querySelectorAll('.table-wrapper');
                    refreshedWrappers.forEach((wrapper, index) => {
                        if (typeof tableScrollPositions[index] === 'number') {
                            wrapper.scrollLeft = tableScrollPositions[index];
                        }
                    });
                });

                pendingUpdate = false;
                attachTableInteractionHandlers();
            }

            const eventSource = new EventSource(`/api/query/stream?${new URLSearchParams({})}`);
            fetch('/api/query/stream', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query: message,
                    conversation_history: conversationHistory
                })
            })
                .then(async response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';

                    while (true) {
                        const { done, value } = await reader.read();

                        if (done) {
                            console.log('Stream complete');
                            break;
                        }
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.substring(6));

                                    if (data.type === 'metadata') {
                                        metadata = data.data;
                                        console.log('Metadata received:', metadata);
                                        assistantMessageDiv = createStreamingMessageContainer(metadata);
                                        textDiv = assistantMessageDiv.querySelector('.message-text');

                                    } else if (data.type === 'content') {
                                        if (textDiv) {
                                            currentText += data.data;
                                            const now = Date.now();

                                            if (updateTimeout) {
                                                clearTimeout(updateTimeout);
                                                updateTimeout = null;
                                            }

                                            if (!pendingUpdate && (now - lastUpdateTime) >= UPDATE_INTERVAL) {
                                                lastUpdateTime = now;
                                                updateContent();
                                            } else {
                                                pendingUpdate = true;
                                                const delay = Math.max(0, UPDATE_INTERVAL - (now - lastUpdateTime));
                                                updateTimeout = setTimeout(() => {
                                                    lastUpdateTime = Date.now();
                                                    updateContent();
                                                    updateTimeout = null;
                                                }, delay);
                                            }
                                            if (!hasRenderedVisibleContent) {
                                                requestAnimationFrame(() => {
                                                    const renderedText = textDiv.innerText.replace('|', '').trim();
                                                    if (!hasRenderedVisibleContent && renderedText.length > 0) {
                                                        hasRenderedVisibleContent = true;
                                                        hideLoading();
                                                        console.log('First content rendered on screen - hiding loading');
                                                        assistantMessageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                                    }
                                                });
                                            }
                                            textDiv.querySelectorAll('pre code').forEach((block) => {
                                                if (window.hljs) window.hljs.highlightElement(block);
                                            });
                                            autoScrollToBottom();
                                            checkPendingTopMessage();
                                        }

                                    } else if (data.type === 'done') {
                                        console.log('Response streaming complete');
                                        if (updateTimeout) {
                                            clearTimeout(updateTimeout);
                                            updateTimeout = null;
                                        }
                                        if (pendingUpdate) {
                                            updateContent(true);
                                        }

                                        if (!hasRenderedVisibleContent) {
                                            hideLoading();
                                        }
                                        checkPendingTopMessage(true);
                                        if (assistantMessageDiv && metadata) {
                                            finalizeStreamingMessage(assistantMessageDiv, currentText, metadata);
                                        }

                                    } else if (data.type === 'error') {
                                        console.error('Stream error:', data.error);
                                        hideLoading();
                                        addMessage(`Error: ${data.error}`, 'assistant', [], true);
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE data:', e, line);
                                }
                            }
                        }
                    }
                })
                .catch(error => {
                    console.error('Detailed error:', error);
                    hideLoading();
                    addMessage(`Error: ${error.message || error}. Check browser console for details.`, 'assistant', [], true);
                });
        }

        function createStreamingMessageContainer(metadata) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message';

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            avatarDiv.innerHTML = '<div class="assistant-avatar"><i class="fas fa-robot"></i></div>';

            const textContentDiv = document.createElement('div');
            textContentDiv.className = 'message-text-container';

            // Add game piece mapping info if available
            if (metadata && metadata.matched_pieces) {
                let matchedPiecesText = '';
                if (Array.isArray(metadata.matched_pieces)) {
                    matchedPiecesText = metadata.matched_pieces.join(', ');
                } else {
                    matchedPiecesText = metadata.matched_pieces.toString();
                }

                if (matchedPiecesText.trim()) {
                    const mappingDiv = document.createElement('div');
                    mappingDiv.className = 'game-piece-mapping';
                    mappingDiv.innerHTML = `
                        <div class="mapping-header">
                            <i class="fas fa-link"></i> Game Piece Mapping
                        </div>
                        <div class="mapping-content">
                            Detected: <strong>${matchedPiecesText}</strong>
                            ${metadata.enhanced_query !== metadata.original_query ?
                            `<br><small>Enhanced search: "${metadata.enhanced_query}"</small>` : ''}
                        </div>
                    `;
                    textContentDiv.appendChild(mappingDiv);
                }
            }

            const textDiv = document.createElement('div');
            textDiv.className = 'message-text';
            textDiv.innerHTML = '<span class="streaming-cursor">|</span>';

            textContentDiv.appendChild(textDiv);
            contentDiv.appendChild(avatarDiv);
            contentDiv.appendChild(textContentDiv);
            messageDiv.appendChild(contentDiv);

            const chatMessages = document.getElementById('chatMessages');
            chatMessages.appendChild(messageDiv);
            autoScrollToBottom();

            return messageDiv;
        }

        function finalizeStreamingMessage(messageDiv, finalText, metadata) {
            const textContentDiv = messageDiv.querySelector('.message-text-container');
            const textDiv = messageDiv.querySelector('.message-text');

            // Add assistant response to conversation history
            conversationHistory.push({
                role: 'assistant',
                content: finalText
            });
            if (conversationHistory.length > 20) {
                conversationHistory = conversationHistory.slice(-20);
            }
            textDiv.innerHTML = formatText(finalText);

            // Add images if present
            if (metadata.images && metadata.images.length > 0) {
                const imagesDiv = document.createElement('div');
                imagesDiv.className = 'message-images';

                const imageHeader = document.createElement('div');
                imageHeader.className = 'image-header';
                imageHeader.innerHTML = `<i class="fas fa-images"></i> Related Images (${metadata.images.length})`;
                imagesDiv.appendChild(imageHeader);

                const imageGrid = document.createElement('div');
                imageGrid.className = 'image-grid';

                metadata.images.forEach((image, index) => {
                    const imageItem = createImageItem(image, index);
                    imageGrid.appendChild(imageItem);
                });

                imagesDiv.appendChild(imageGrid);
                textContentDiv.appendChild(imagesDiv);
            }

            // Add feedback buttons
            const feedbackDiv = document.createElement('div');
            feedbackDiv.className = 'feedback-buttons';

            const feedbackLabel = document.createElement('div');
            feedbackLabel.className = 'feedback-label';
            feedbackLabel.textContent = 'Was this response helpful?';

            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'feedback-button-container';

            const goodButton = document.createElement('button');
            goodButton.className = 'feedback-btn feedback-good';
            goodButton.innerHTML = '<i class="fas fa-thumbs-up"></i> Good';
            goodButton.onclick = () => submitFeedback(finalText, 'good', feedbackDiv);

            const badButton = document.createElement('button');
            badButton.className = 'feedback-btn feedback-bad';
            badButton.innerHTML = '<i class="fas fa-thumbs-down"></i> Bad';
            badButton.onclick = () => submitFeedback(finalText, 'bad', feedbackDiv);

            const redoButton = document.createElement('button');
            redoButton.className = 'feedback-btn feedback-redo';
            redoButton.innerHTML = '<i class="fas fa-redo"></i> Redo';
            redoButton.onclick = () => submitFeedback(finalText, 'redo', feedbackDiv);

            buttonsContainer.appendChild(goodButton);
            buttonsContainer.appendChild(badButton);
            buttonsContainer.appendChild(redoButton);

            feedbackDiv.appendChild(feedbackLabel);
            feedbackDiv.appendChild(buttonsContainer);
            textContentDiv.appendChild(feedbackDiv);
            messageDiv.classList.add('latest-assistant-message');
            const chatMessages = document.getElementById('chatMessages');
            const previousLatestMessages = chatMessages.querySelectorAll('.latest-assistant-message');
            previousLatestMessages.forEach(msg => {
                if (msg !== messageDiv) {
                    msg.classList.remove('latest-assistant-message');
                    const redoBtn = msg.querySelector('.feedback-redo');
                    if (redoBtn) redoBtn.remove();
                }
            });

            autoScrollToBottom();
        }


        // Initialize
        document.addEventListener('DOMContentLoaded', function () {
            console.log('DOM loaded, focusing input');
            messageInput.focus();
            console.log('Page fully loaded and ready!');

            // New Chat button handler
            const newChatBtn = document.querySelector('.new-chat-btn');
            if (newChatBtn) {
                newChatBtn.addEventListener('click', function () {
                    // Clear conversation history
                    conversationHistory = [];

                    // Clear chat messages except welcome message
                    const chatMessages = document.getElementById('chatMessages');
                    const welcomeMessage = chatMessages.querySelector('.welcome-message');
                    chatMessages.innerHTML = '';
                    if (welcomeMessage) {
                        chatMessages.appendChild(welcomeMessage);
                    }

                    // Clear input
                    messageInput.value = '';
                    messageInput.focus();

                    console.log('New chat started - conversation history cleared');
                });
            }
        });
    </script>
</body>

</html>